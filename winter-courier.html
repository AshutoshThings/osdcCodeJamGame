<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Winter Courier - Frozen City Deliveries</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        position: fixed;
        overflow: hidden;
        background: linear-gradient(to bottom, #0a0a20, #1a1a3e);
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        font-family: "Segoe UI", sans-serif;
      }
      #game {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }
      #hud {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        justify-content: space-between;
        color: #fff;
        font-size: 14px;
        pointer-events: none;
        z-index: 100;
      }
      .hud-item {
        background: rgba(0, 0, 0, 0.7);
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid #4fc3f7;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        animation: pulse 2s ease-in-out infinite;
      }
      .hud-item:nth-child(2) {
        animation-delay: 0.2s;
      }
      .hud-item:nth-child(3) {
        animation-delay: 0.4s;
      }
      .hud-item:nth-child(4) {
        animation-delay: 0.6s;
      }
      .hud-item:nth-child(5) {
        animation-delay: 0.8s;
      }
      .hud-item:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(79, 195, 247, 0.6);
      }
      #stamina-bar {
        width: 100px;
        height: 12px;
        background: #333;
        border-radius: 6px;
        overflow: hidden;
        margin-top: 4px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      #stamina-fill {
        height: 100%;
        background: linear-gradient(90deg, #f44, #ff0, #0f0);
        transition: width 0.1s, box-shadow 0.3s;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
      }
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
        text-align: center;
        border-radius: 8px;
        z-index: 1000;
      }
      .overlay.hidden {
        display: none;
      }
      h1 {
        color: #4fc3f7;
        font-size: 36px;
        margin-bottom: 10px;
        animation: slideIn 0.5s ease-out;
      }
      h2 {
        color: #ffd93d;
        font-size: 18px;
        margin-bottom: 20px;
        animation: slideIn 0.5s ease-out;
      }
      .info {
        max-width: 450px;
        margin-bottom: 20px;
        line-height: 1.5;
      }
      button {
        background: linear-gradient(#4fc3f7, #0288d1);
        border: none;
        color: #fff;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        animation: glow 2s ease-in-out infinite;
        transition: all 0.3s;
      }
      button:hover {
        transform: scale(1.1);
        box-shadow: 0 0 25px rgba(79, 195, 247, 1);
      }
      .key {
        background: #4fc3f7;
        color: #000;
        padding: 2px 6px;
        border-radius: 3px;
        font-weight: bold;
      }
      #target {
        position: absolute;
        top: 55px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: #ffd93d;
        padding: 5px 15px;
        border-radius: 15px;
        border: 1px solid #ffd93d;
        font-size: 13px;
      }
      #target.hidden {
        display: none;
      }
      #minimap {
        position: absolute;
        bottom: 10px;
        right: 10px;
        border: 2px solid #4fc3f7;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.6);
        z-index: 100;
        box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
      }
      #pause {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        color: #fff;
        padding: 30px 50px;
        border-radius: 15px;
        border: 2px solid #4fc3f7;
        text-align: center;
        display: none;
        z-index: 1000;
        box-shadow: 0 0 30px rgba(79, 195, 247, 0.8);
      }
      #pause.show {
        display: block;
      }
      .particle {
        position: absolute;
        pointer-events: none;
        border-radius: 50%;
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
          opacity: 0.9;
        }
      }
      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      @keyframes glow {
        0%,
        100% {
          box-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
        }
        50% {
          box-shadow: 0 0 15px rgba(79, 195, 247, 1);
        }
      }
      .combo {
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd93d;
        font-size: 32px;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .combo.show {
        opacity: 1;
        animation: comboPop 0.6s ease-out;
      }
      @keyframes comboPop {
        0% {
          transform: translateX(-50%) scale(0.5);
          opacity: 0;
        }
        50% {
          transform: translateX(-50%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translateX(-50%) scale(1);
          opacity: 0;
        }
      }
      .achievement {
        position: absolute;
        top: 20%;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        color: #4caf50;
        padding: 12px 18px;
        border-radius: 6px;
        border: 1px solid #4caf50;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        transform: translateX(400px);
        opacity: 0;
        transition: all 0.4s ease;
        z-index: 100;
        pointer-events: none;
        font-size: 14px;
      }
      .achievement.show {
        transform: translateX(0);
        opacity: 1;
      }
      .achievement-icon {
        font-size: 24px;
        margin-right: 10px;
      }
      .score-popup {
        position: absolute;
        pointer-events: none;
        color: #4caf50;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(76, 175, 80, 0.8);
        z-index: 200;
        opacity: 0;
      }
      .score-popup.show {
        animation: scoreFloat 1s ease-out forwards;
      }
      @keyframes scoreFloat {
        0% {
          transform: translateY(0) scale(0.5);
          opacity: 0;
        }
        20% {
          opacity: 1;
          transform: translateY(-10px) scale(1.2);
        }
        100% {
          transform: translateY(-60px) scale(0.8);
          opacity: 0;
        }
      }
      .level-up {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        color: #fff;
        font-size: 24px;
        font-weight: normal;
        background: rgba(0, 0, 0, 0.75);
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 300;
        pointer-events: none;
        opacity: 0;
      }
      .level-up.show {
        animation: levelUpPop 1.5s ease-out forwards;
      }
      @keyframes levelUpPop {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        30% {
          transform: translate(-50%, -50%) scale(1.3);
          opacity: 1;
        }
        60% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0;
        }
      }
      .delivery-success {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translateX(-50%) scale(0);
        color: #4caf50;
        font-size: 36px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
        z-index: 250;
        pointer-events: none;
        opacity: 0;
      }
      .delivery-success.show {
        animation: deliveryPop 0.8s ease-out forwards;
      }
      @keyframes deliveryPop {
        0% {
          transform: translateX(-50%) scale(0) rotate(-10deg);
          opacity: 0;
        }
        50% {
          transform: translateX(-50%) scale(1.2) rotate(5deg);
          opacity: 1;
        }
        100% {
          transform: translateX(-50%) scale(1) rotate(0deg);
          opacity: 0;
        }
      }
      canvas {
        box-shadow: 0 0 30px rgba(79, 195, 247, 0.3);
        transition: box-shadow 0.3s;
      }
      canvas:hover {
        box-shadow: 0 0 40px rgba(79, 195, 247, 0.5);
      }
      .stats-panel {
        position: absolute;
        bottom: 80px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid #4fc3f7;
        font-size: 12px;
        color: #fff;
        opacity: 0.7;
        transition: opacity 0.3s;
        pointer-events: none;
      }
      .stats-panel:hover {
        opacity: 1;
      }
      .stats-item {
        margin: 3px 0;
      }
      /* Level Generator Styles */
      .start-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }
      #levelGenBtn {
        background: linear-gradient(#9c27b0, #7b1fa2);
      }
      #levelGenBtn:hover {
        box-shadow: 0 0 25px rgba(156, 39, 176, 1);
      }
      .level-gen-content {
        max-width: 500px;
        text-align: center;
      }
      .level-gen-content textarea {
        width: 100%;
        height: 100px;
        padding: 12px;
        border: 2px solid #4fc3f7;
        border-radius: 8px;
        background: rgba(0,0,0,0.5);
        color: #fff;
        font-size: 14px;
        resize: none;
        margin: 15px 0;
      }
      .level-gen-content textarea:focus {
        outline: none;
        border-color: #81d4fa;
        box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
      }
      .quick-gen {
        margin: 20px 0;
        padding: 15px;
      }
      .quick-gen button {
        margin: 5px;
        padding: 8px 20px;
        font-size: 14px;
      }
      .cancel-btn {
        background: linear-gradient(#666, #444) !important;
        margin-top: 10px;
      }
      #level-preview {
        background: rgba(79, 195, 247, 0.2);
        border: 1px solid #4fc3f7;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        max-width: 400px;
      }
      .level-info h3 {
        color: #ffd93d;
        margin-bottom: 8px;
      }
      .level-stats {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 10px;
        font-size: 13px;
      }
      .level-stats span {
        background: rgba(0,0,0,0.3);
        padding: 4px 10px;
        border-radius: 4px;
      }
      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255,255,255,0.3);
        border-top-color: #4fc3f7;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div id="game">
        <canvas id="c" width="900" height="500"></canvas>
        <canvas id="minimap" width="160" height="60"></canvas>

      <div id="hud" class="hidden">
        <div class="hud-item">Level: <span id="lvl">1</span></div>
        <div class="hud-item">Score: <span id="scr">0</span></div>
        <div class="hud-item">üì¶ <span id="pkg">0</span>/3</div>
        <div class="hud-item">
          Deliveries: <span id="del">0</span>/<span id="need">5</span>
        </div>
        <div class="hud-item" id="combo-hud" style="display: none;">
          Combo: <span id="combo-count">0</span>x
        </div>
        <div
          class="hud-item"
          id="thief-warning"
          style="opacity: 0; background: linear-gradient(135deg, #4a7c59, #2d5a3d); color: #fff; border-color: #4a7c59; text-shadow: 0 0 10px rgba(74, 124, 89, 0.8); font-weight: bold;"
        >
          üéÑ GRINCH ALERT!
        </div>
        <div
          class="hud-item"
          id="hp-low-warning"
          style="
            opacity: 0;
            color: #ff4444;
            border-color: #ff4444;
            animation: none;
          "
        >
          ‚ö†Ô∏è DANGER! 1 HP LEFT!
        </div>
        <div class="hud-item">
          Stamina
          <div id="stamina-bar"><div id="stamina-fill"></div></div>
        </div>
        <div class="hud-item" id="health-display" style="font-size: 20px;">
          ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è
        </div>
        <div id="turbo-indicator" class="hud-item" style="display: none; background: linear-gradient(135deg, #4fc3f7, #2196f3); animation: pulse 0.3s infinite;">
          üöÄ TURBO!
        </div>
      </div>

      <div
        id="mission"
        class="hidden"
        style="
          position: absolute;
          top: 70px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.9);
          color: #ffd93d;
          padding: 10px 20px;
          border-radius: 10px;
          border: 2px solid #ffd93d;
          font-size: 14px;
          text-align: center;
          z-index: 50;
        "
      >
        <div style="font-weight: bold; margin-bottom: 5px">üìã MISSION:</div>
        <div id="mission-text">Complete deliveries</div>
      </div>

      <div id="target" class="hidden">
        üè† <span id="tname">--</span> | <span id="tdist">--</span>m
      </div>

      <div id="start" class="overlay">
        <h1 style="font-size: 28px; margin-bottom: 30px; font-weight: normal;">Winter Courier</h1>
        
        <div class="info" style="font-size: 13px; line-height: 2.2; max-width: 450px; text-align: center;">
          <div style="margin-bottom: 20px;">
            <span class="key">A/D</span> Move &nbsp;&nbsp;
            <span class="key">W/Space</span> Jump &nbsp;&nbsp;
            <span class="key">Shift</span> Sprint
          </div>
          <div style="margin-bottom: 20px;">
            <span class="key">P</span> Pause &nbsp;&nbsp;
            <span class="key">ESC</span> Menu
          </div>
          <div style="margin-bottom: 15px; opacity: 0.8;">
            Collect packages from warehouse<br />
            Deliver to marked houses
          </div>
          <div style="opacity: 0.8;">
            Avoid falling ice &nbsp;¬∑&nbsp; Jump on Grinch to defeat
          </div>
        </div>
        
        <div id="level-preview" class="hidden" style="display: none;"></div>
        <div class="start-buttons" style="margin-top: 30px;">
          <button id="startBtn">Start Game</button>
          <button id="levelGenBtn" onclick="showLevelGeneratorModal()">Generate Level</button>
        </div>
      </div>

      <!-- Level Generator Modal -->
      <div id="level-gen-modal" class="overlay hidden">
        <h2>AI Level Generator</h2>
        <div class="level-gen-content">
          <p style="margin-bottom: 20px;">Choose your challenge level</p>
          <div class="quick-gen">
            <button onclick="generateQuickLevel('easy')" style="background: linear-gradient(#4caf50, #388e3c);">Easy</button>
            <button onclick="generateQuickLevel('medium')" style="background: linear-gradient(#ff9800, #f57c00);">Medium</button>
            <button onclick="generateQuickLevel('hard')" style="background: linear-gradient(#f44336, #c62828);">Hard</button>
          </div>
          <button class="cancel-btn" onclick="hideLevelGeneratorModal()">Cancel</button>
        </div>
      </div>

      <!-- Level Generation Loading Overlay -->
      <div id="level-gen-overlay" class="overlay hidden">
        <div class="loading-spinner"></div>
        <h2>Generating Level...</h2>
        <p>AI is crafting your custom level</p>
      </div>

      <div id="gameover" class="overlay hidden">
        <h1>‚ùÑÔ∏è Game Over ‚ùÑÔ∏è</h1>
        <h2>Final Score: <span id="fscore">0</span></h2>
        <div class="info">
          Level <span id="flvl">1</span> | Deliveries: <span id="fdel">0</span>
        </div>
        <button id="restartBtn">Play Again</button>
      </div>

      <div id="pause">
        <h2>Paused</h2>
        <p>
          Press <span class="key">P</span> to resume
        </p>
      </div>

      <div id="combo" class="combo"></div>
      <div id="achievement" class="achievement">
        <span class="achievement-icon"></span>
        <span class="achievement-text"></span>
      </div>
      <div id="level-up" class="level-up">LEVEL UP!</div>
      <div id="delivery-success" class="delivery-success">‚úì DELIVERED!</div>
      <div id="stats" class="stats-panel hidden">
        <div class="stats-item">‚è±Ô∏è Time: <span id="game-time">0</span>s</div>
        <div class="stats-item">
          ‚ö° Best Combo: <span id="best-combo">0</span>
        </div>
        <div class="stats-item">
          üéØ Accuracy: <span id="accuracy">100</span>%
        </div>
      </div>
    </div>
    <script src="audio.js"></script>
    <script src="level-generator.js"></script>

    <script>
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      const mini = document.getElementById("minimap");
      const mctx = mini.getContext("2d");

      // Set canvas to full window size
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let W = canvas.width,
        H = canvas.height;
      const WORLD_W = 3000;
      let GROUND = H - 50;

      let state = "start";
      let level = 1,
        score = 0,
        delivered = 0,
        needed = 5;

      // Camera
      let camX = 0;

      // Player
      const P = {
        x: 150,
        y: GROUND - 45,
        w: 30,
        h: 45,
        vx: 0,
        vy: 0,
        health: 3, // 3 hearts - lose one when hit by ice
        stamina: 100, // For sprinting and jumping
        packages: 0,
        grounded: false,
        right: true,
      };

      const GRAV = 0.6,
        FRIC = 0.88,
        ACCEL = 0.9,
        SPRINT = 1.6,
        MAX_V = 8,
        JUMP = -11; // Lower jump - requires platforms to reach elevated houses
      
      // Better control feel - coyote time & jump buffer
      let coyoteTime = 0; // Frames since leaving ground
      let jumpBuffer = 0; // Frames since jump pressed
      const COYOTE_FRAMES = 8; // ~133ms grace period
      const JUMP_BUFFER_FRAMES = 10; // ~166ms buffer

      // Objects - initialize with defaults
      let warehouse = { x: 80, y: GROUND - 90, w: 120, h: 90, stock: 10 };
      let houses = [];
      let platforms = [];
      let iceBlocks = [];
      let snow = [];
      let particles = [];
      let powerUps = [];
      let obstacles = [];
      let combo = 0;
      let comboTime = 0;
      let screenShake = 0;
      let thief = null;
      let thiefSpawnTime = 0;
      let thiefDefeated = false;
      let thiefHitCooldown = 0;
      let damageNumbers = [];
      let scorePopups = [];
      let playerTrail = [];
      let gameStartTime = 0;
      let bestCombo = 0;
      let totalDeliveries = 0;
      let successfulDeliveries = 0;
      let currentMission = null;
      let missionProgress = 0;
      let missionTarget = 0;
      let turboActive = false;
      let turboTimer = 0;
      
      // Sound effects
      const grinchKilledSound = new Audio('sounds/grinchKilled.mp3');
      grinchKilledSound.volume = 0.7;

      // Particle system
      function createParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 1,
            decay: 0.02 + Math.random() * 0.02,
            size: 2 + Math.random() * 3,
            color: color,
          });
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1; // gravity
          p.life -= p.decay;
          if (p.life <= 0) particles.splice(i, 1);
        }
      }

      function drawParticles() {
        for (const p of particles) {
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          // Particles use world coordinates - camera transform is already applied
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function init() {
        // Check for custom level
        const customLevel = window.customLevel;
        
        // Warehouse
        warehouse = { x: 80, y: GROUND - 90, w: 120, h: 90, stock: 10 };

        // Houses - use custom or procedurally generate with variety
        houses = [];
        const elevatedPlatforms = []; // Platforms for elevated houses
        if (customLevel && customLevel.houses) {
          customLevel.houses.forEach((h, i) => {
            houses.push({
              x: h.x,
              y: GROUND - 70,
              w: 80,
              h: 70,
              color: h.color || ["#c0392b", "#27ae60", "#2980b9", "#8e44ad", "#d35400"][i % 5],
              needs: false,
              done: false,
              name: "House " + (i + 1),
              missionTarget: false,
              elevated: false,
            });
          });
        } else {
          // Procedural house placement - varies each level!
          const houseCount = 6 + Math.min(level, 4); // 6-10 houses based on level
          const minSpacing = 280; // Minimum distance between houses
          const startX = 350;
          const endX = WORLD_W - 200;
          
          // Generate varied positions
          let currentX = startX;
          for (let i = 0; i < houseCount && currentX < endX; i++) {
            // Add some randomness to spacing
            const spacing = minSpacing + Math.random() * 150;
            const houseX = currentX + Math.random() * 60 - 30;
            
            // Elevated houses: more as levels increase, but not first 2 houses
            const elevationChance = Math.min(0.1 + level * 0.05, 0.4); // 10%-40% chance
            const isElevated = i >= 2 && Math.random() < elevationChance;
            const platformHeight = isElevated ? 120 + Math.random() * 40 : 0;
            
            // Vary house size slightly
            const houseW = 70 + Math.random() * 20;
            const houseH = 60 + Math.random() * 20;
            
            if (isElevated) {
              // Create a platform for the elevated house
              elevatedPlatforms.push({
                x: houseX - 15,
                y: GROUND - platformHeight,
                w: houseW + 30,
                h: 14,
                moving: false,
                dir: 1,
                speed: 0,
                start: houseX - 15,
                range: 0,
              });
            }
            
            // Festive house colors with more variety
            const colors = [
              "#c0392b", "#27ae60", "#2980b9", "#8e44ad", "#d35400",
              "#e74c3c", "#16a085", "#2c3e50", "#9b59b6", "#f39c12"
            ];
            
            houses.push({
              x: houseX,
              y: GROUND - houseH - platformHeight,
              w: houseW,
              h: houseH,
              color: colors[i % colors.length],
              needs: false,
              done: false,
              name: isElevated ? "Treehouse " + (i + 1) : "House " + (i + 1),
              missionTarget: false,
              elevated: isElevated,
            });
            
            currentX += spacing;
          }
        }

        // Platforms - use custom or add helper platforms for elevated houses
        platforms = [];
        // First add elevated house platforms
        platforms.push(...elevatedPlatforms);
        
        if (customLevel && customLevel.platforms) {
          customLevel.platforms.forEach((p) => {
            // Use heightAboveGround (60-120 range) to calculate Y position
            const height = Math.min(Math.max(p.heightAboveGround || 80, 60), 120);
            const isMoving = p.moving !== undefined ? p.moving : false;
            platforms.push({
              x: p.x,
              y: GROUND - height,
              w: p.width || 80,
              h: 14,
              moving: isMoving,
              dir: 1,
              speed: p.speed || (1 + Math.random()),
              start: p.x,
              range: 60,
            });
          });
        } else {
          // Create challenging platform sequences for elevated houses
          // Requires timing multiple moving platforms
          let platformIndex = 0;
          houses.forEach((house) => {
            if (house.elevated) {
              const baseX = house.x - 180;
              
              // Platform 1: Low moving platform - starting point
              platforms.push({
                x: baseX,
                y: GROUND - 50,
                w: 55,
                h: 14,
                moving: true,
                dir: 1,
                speed: 1.8,
                start: baseX,
                range: 35,
              });
              
              // Platform 2: Mid-height moving platform - moves opposite direction
              platforms.push({
                x: baseX + 70,
                y: GROUND - 90,
                w: 50,
                h: 14,
                moving: true,
                dir: -1,
                speed: 2.0,
                start: baseX + 70,
                range: 30,
              });
              
              // Platform 3: High moving platform - final jump to house
              platforms.push({
                x: baseX + 130,
                y: GROUND - 120,
                w: 45,
                h: 14,
                moving: true,
                dir: 1,
                speed: 1.5,
                start: baseX + 130,
                range: 25,
              });
              
              platformIndex++;
            }
          });
        }

        // Ice - use custom settings or default
        const iceCount = (customLevel && customLevel.iceCount) || (12 + level * 2);
        const iceSpeedMult = (customLevel && customLevel.iceSpeed) || 1.0;
        iceBlocks = [];
        for (let i = 0; i < iceCount; i++) {
          iceBlocks.push({
            x: Math.random() * WORLD_W,
            y: -Math.random() * 600,
            size: 15 + Math.random() * 10,
            speed: (2 + Math.random() * 2 + level * 0.3) * iceSpeedMult,
            rot: 0,
          });
        }

        // Snow
        snow = [];
        for (let i = 0; i < 100; i++) {
          snow.push({
            x: Math.random() * WORLD_W,
            y: Math.random() * H,
            r: 1 + Math.random() * 2,
            s: 0.5 + Math.random(),
          });
        }

        // Obstacles (snowdrifts slow down, ice blocks are solid barriers)
        obstacles = [];
        // Add slowing obstacles (snowdrifts)
        for (let i = 0; i < 4 + Math.floor(level / 2); i++) {
          const h = 20 + Math.random() * 25;
          obstacles.push({
            x: 600 + Math.random() * (WORLD_W - 800),
            y: GROUND - h,
            w: 40 + Math.random() * 30,
            h: h,
            type: "snowdrift" // Slows down player
          });
        }
        // Add solid blocking obstacles (ice blocks/barriers)
        for (let i = 0; i < 3 + Math.floor(level / 2); i++) {
          const h = 50 + Math.random() * 40; // Taller than player
          obstacles.push({
            x: 700 + Math.random() * (WORLD_W - 900),
            y: GROUND - h,
            w: 25 + Math.random() * 15,
            h: h,
            type: "iceblock" // Solid barrier - blocks movement
          });
        }

        // Power-ups - Health (restores 1 heart) and Turbo only
        // Placed at fixed strategic locations, respawn after collection
        powerUps = [
          // Health powerup at far left (safe zone near warehouse)
          { x: 250, y: GROUND - 40, type: "health", rot: 0, collected: false, respawnTimer: 0 },
          // Health powerup in middle of map
          { x: WORLD_W / 2, y: GROUND - 40, type: "health", rot: 0, collected: false, respawnTimer: 0 },
          // Health powerup at far right
          { x: WORLD_W - 300, y: GROUND - 40, type: "health", rot: 0, collected: false, respawnTimer: 0 },
          // Turbo powerup - one in the middle area
          { x: WORLD_W / 3, y: GROUND - 40, type: "turbo", rot: 0, collected: false, respawnTimer: 0 },
          // Turbo powerup - one in the right area  
          { x: WORLD_W * 2 / 3, y: GROUND - 40, type: "turbo", rot: 0, collected: false, respawnTimer: 0 },
        ];

        // Thief (Grinch) - use custom settings
        const thiefEnabled = customLevel ? customLevel.thiefEnabled !== false : true;
        thief = null;
        thiefSpawnTime = thiefEnabled ? (180 + level * 60) : 999999;
        thiefDefeated = !thiefEnabled;
        thiefHitCooldown = 0;
        
        // Set deliveries needed from custom level
        if (customLevel && customLevel.deliveriesNeeded) {
          needed = customLevel.deliveriesNeeded;
        } else {
          needed = 4 + level * 2;
        }
        damageNumbers = [];

        // Reset player
        P.x = 150;
        P.y = GROUND - 45;
        P.vx = 0;
        P.vy = 0;
        P.health = 3;
        P.stamina = 100;
        P.packages = 0;

        delivered = 0;
        needed = 4 + level * 2;
        camX = 0;
        combo = 0;
        comboTime = 0;
        particles = [];
        screenShake = 0;
        missionProgress = 0;

        // Generate mission for this level
        generateMission();

        assignDeliveries();
        updateHUD();
      }

      function generateMission() {
        // Cap delivery target at number of houses
        const maxDeliveries = houses.length;
        const missionTypes = [
          {
            type: "deliver",
            text: (target) => `Deliver ${target} packages`,
            target: Math.min(3 + level, maxDeliveries),
            progress: () => delivered,
          },
          // ... (other mission types unchanged)
          {
            type: "specific",
            text: (houses, target) => {
              const targetHouses = houses.filter((h) => h.missionTarget);
              return `Deliver to: ${targetHouses
                .map((h) => h.name)
                .join(", ")}`;
            },
            target: (houses) => {
              const availableHouses = houses.filter((h) => !h.done);
              return Math.min(
                2 + Math.floor(level / 2),
                availableHouses.length
              );
            },
            progress: (houses) => {
              const targetHouses = houses.filter((h) => h.missionTarget);
              return targetHouses.filter((h) => h.done).length;
            },
            specific: true,
          },
        ];

        let candidates = missionTypes.slice();

        const availablePowerUps = powerUps.filter((pu) => !pu.collected).length;
        const powerUpMissionTarget = 2 + level;
        if (availablePowerUps < powerUpMissionTarget) {
          candidates = candidates.filter((m) => m.type !== "powerups");
        }

        const availableHouses = houses.filter((h) => !h.done);
        const specificMissionTarget = Math.min(
          2 + Math.floor(level / 2),
          availableHouses.length
        );
        if (specificMissionTarget === 0) {
          candidates = candidates.filter((m) => m.type !== "specific");
        }

        // Selection logic
        let selectedMission;
        if (level === 1) {
          selectedMission =
            candidates.find((m) => m.type === "deliver") || candidates[0];
        } else if (level % 3 === 0) {
          selectedMission =
            candidates.find((m) => m.type === "thief") || candidates[0];
        } else {
          selectedMission =
            candidates[Math.floor(Math.random() * candidates.length)] ||
            missionTypes[0];
        }

        // Calculate final target
        const finalTarget =
          typeof selectedMission.target === "function"
            ? selectedMission.target(houses)
            : selectedMission.target;

        currentMission = {
          type: selectedMission.type,
          text: "", // Placeholder until the text is correctly generated below
          target: finalTarget,
          progress: selectedMission.progress,
          specific: selectedMission.specific || false,
        };

        // For specific missions, mark target houses
        if (currentMission.specific && currentMission.type === "specific") {
          // Reset missionTarget flag first
          houses.forEach((h) => (h.missionTarget = false));
          const targetHouses = houses
            .filter((h) => !h.done)
            .slice(0, currentMission.target);
          targetHouses.forEach((h) => (h.missionTarget = true));

          // Generate text *after* marking targets (requires houses and target)
          currentMission.text = selectedMission.text(
            houses,
            currentMission.target
          );
        } else {
          // Generate text for non-specific missions (only requires target)
          // Check if text is a function, and pass the target
          currentMission.text =
            typeof selectedMission.text === "function"
              ? selectedMission.text(currentMission.target)
              : selectedMission.text;
        }

        missionTarget = currentMission.target;
        missionProgress = currentMission.progress(houses); // Initial progress check

        // Update mission display
        document.getElementById(
          "mission-text"
        ).textContent = `${currentMission.text} (${missionProgress}/${missionTarget})`;
        document.getElementById("mission").classList.remove("hidden");
      }

      function assignDeliveries() {
        houses.forEach((h) => (h.needs = false));

        // Only assign deliveries to houses that are not done and, if applicable, are mission targets
        let avail = houses.filter((h) => !h.done);

        if (currentMission && currentMission.type === "specific") {
          avail = houses.filter((h) => h.missionTarget && !h.done);
        }

        const n = Math.min(P.packages > 0 ? 1 : 3, avail.length); // Max 3 deliveries needed at once
        for (let i = 0; i < n; i++) {
          const idx = Math.floor(Math.random() * avail.length);
          avail[idx].needs = true;
          avail.splice(idx, 1);
        }

        // If no houses need delivery, but we have packages, find the nearest available one
        if (P.packages > 0 && houses.filter((h) => h.needs).length === 0) {
          let fallbackHouses = houses.filter((h) => !h.done);
          if (currentMission && currentMission.type === "specific") {
            fallbackHouses = fallbackHouses.filter((h) => h.missionTarget);
          }
          if (fallbackHouses.length > 0) {
            const nearest = fallbackHouses.reduce(
              (prev, curr) =>
                Math.abs(curr.x - P.x) < Math.abs(prev.x - P.x) ? curr : prev,
              fallbackHouses[0]
            );
            nearest.needs = true;
          }
        }
      }

      function updateHUD() {
        document.getElementById("lvl").textContent = level;
        document.getElementById("scr").textContent = score;
        document.getElementById("pkg").textContent = P.packages;
        document.getElementById("del").textContent = delivered;
        document.getElementById("need").textContent = needed;
        document.getElementById("stamina-fill").style.width = P.stamina + "%";
        
        // Update health display
        let hearts = "";
        for (let i = 0; i < 3; i++) {
          hearts += i < P.health ? "‚ù§Ô∏è" : "üíî";
        }
        document.getElementById("health-display").textContent = hearts;
        
        // Turbo indicator
        const turboIndicator = document.getElementById("turbo-indicator");
        turboIndicator.style.display = turboActive ? "block" : "none";

        // Combo display
        const comboHud = document.getElementById("combo-hud");
        const comboCount = document.getElementById("combo-count");
        if (combo > 0) {
          comboHud.style.opacity = "1";
          comboCount.textContent = combo;
          comboHud.style.color = combo > 5 ? "#ffd93d" : "#fff";
        } else {
          comboHud.style.opacity = "0";
        }

        // Thief warning
        const thiefWarning = document.getElementById("thief-warning");
        if (thief && !thiefDefeated) {
          thiefWarning.style.display = "block";
          const dist = Math.abs(P.x - thief.x);
          if (dist < 300) {
            const pulse = 0.7 + Math.sin(Date.now() / 100) * 0.3;
            thiefWarning.style.opacity = pulse;
          } else {
            thiefWarning.style.opacity = "0.5";
          }
        } else {
          thiefWarning.style.opacity = "0";
          thiefWarning.style.display = "none";
        }

        // Low health warning
        const hpLowWarning = document.getElementById("hp-low-warning");
        if (P.health === 1) {
          const pulse = 0.5 + Math.sin(Date.now() / 150) * 0.5;
          hpLowWarning.style.opacity = pulse;
        } else {
          hpLowWarning.style.opacity = "0";
        }

        // Update mission progress
        if (currentMission) {
          missionProgress = currentMission.progress(houses);
          const missionEl = document.getElementById("mission-text");
          missionEl.textContent = `${currentMission.text} (${missionProgress}/${missionTarget})`;
        }

        // Stamina bar color based on level
        const staminaFill = document.getElementById("stamina-fill");
        if (P.stamina > 60) {
          staminaFill.style.background =
            "linear-gradient(90deg, #0f0, #4caf50)";
        } else if (P.stamina > 30) {
          staminaFill.style.background =
            "linear-gradient(90deg, #ff0, #ffd93d)";
        } else {
          staminaFill.style.background =
            "linear-gradient(90deg, #f44, #d32f2f)";
        }

        const t = houses.find((h) => h.needs);
        if (P.packages > 0 && t) {
          document.getElementById("target").classList.remove("hidden");
          document.getElementById("tname").textContent = t.name;
          document.getElementById("tdist").textContent = Math.round(
            Math.abs(t.x - P.x) / 8
          );
        } else {
          document.getElementById("target").classList.add("hidden");
        }
      }

      // Input
      const keys = {};
      let paused = false;
      document.addEventListener("keydown", (e) => {
        // Don't capture keys when typing in input/textarea
        const activeEl = document.activeElement;
        const isTyping = activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA");
        
        if (isTyping) return; // Let typing work normally
        
        keys[e.code] = true;
        if (["Space", "ArrowUp", "ArrowDown"].includes(e.code))
          e.preventDefault();
        // Buffer jump input for better responsiveness
        if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") {
          jumpBuffer = JUMP_BUFFER_FRAMES;
        }
        // P for pause
        if (e.code === "KeyP" && state === "play") {
          paused = !paused;
          document.getElementById("pause").classList.toggle("show", paused);
        }
        // ESC returns to start screen
        if (e.code === "Escape" && state === "play") {
          paused = false;
          document.getElementById("pause").classList.remove("show");
          state = "start";
          document.getElementById("hud").classList.add("hidden");
          document.getElementById("target").classList.add("hidden");
          document.getElementById("mission").classList.add("hidden");
          document.getElementById("stats").classList.add("hidden");
          document.getElementById("start").classList.remove("hidden");
          window.customLevel = null;
          const preview = document.getElementById("level-preview");
          if (preview) preview.style.display = "none";
          const startBtn = document.getElementById("startBtn");
          if (startBtn) startBtn.textContent = "Start Game";
        }
      });
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      document.getElementById("startBtn").onclick = startGame;
      document.getElementById("restartBtn").onclick = startGame;

      function startGame() {
        state = "play";
        level = 1;
        score = 0;
        gameStartTime = Date.now();
        bestCombo = 0;
        totalDeliveries = 0;
        successfulDeliveries = 0;
        playerTrail = [];
        scorePopups = [];
        document.getElementById("start").classList.add("hidden");
        document.getElementById("gameover").classList.add("hidden");
        document.getElementById("hud").classList.remove("hidden");
        document.getElementById("stats").classList.remove("hidden");
        init();
      }

      function endGame() {
        state = "over";
        document.getElementById("hud").classList.add("hidden");
        document.getElementById("target").classList.add("hidden");
        document.getElementById("mission").classList.add("hidden");
        document.getElementById("stats").classList.add("hidden");
        document.getElementById("gameover").classList.remove("hidden");
        document.getElementById("fscore").textContent = score;
        document.getElementById("flvl").textContent = level;
        document.getElementById("fdel").textContent = delivered;
        window.dispatchEvent(new Event("game-over"));
      }

      function nextLevel() {
        level++;
        score += 50 + combo * 5;
        createParticles(P.x + P.w / 2, P.y + P.h / 2, "#4fc3f7", 30);
        screenShake = 4; // Minimal shake for level up
        // Show level up animation - just the level number
        const levelUpEl = document.getElementById("level-up");
        levelUpEl.textContent = `Level ${level}`;
        levelUpEl.classList.add("show");
        setTimeout(() => levelUpEl.classList.remove("show"), 1500);

        // Reset completed houses for next level
        houses.forEach((h) => (h.done = false));

        init();
      }

      // Score popup system
      function showScorePopup(x, y, text, color = "#4caf50") {
        scorePopups.push({
          x: x,
          y: y,
          text: text,
          color: color,
          life: 60,
          vy: -2,
        });
      }

      // Achievement system
      function showAchievement(icon, text) {
        const achEl = document.getElementById("achievement");
        achEl.querySelector(".achievement-icon").textContent = icon;
        achEl.querySelector(".achievement-text").textContent = text;
        achEl.classList.add("show");
        setTimeout(() => achEl.classList.remove("show"), 3000);
      }

      // Update player trail
      function updateTrail() {
        if (Math.abs(P.vx) > 0.5 || Math.abs(P.vy) > 0.5) {
          playerTrail.push({
            x: P.x + P.w / 2,
            y: P.y + P.h / 2,
            life: 20,
            alpha: 0.5,
          });
        }

        for (let i = playerTrail.length - 1; i >= 0; i--) {
          playerTrail[i].life--;
          playerTrail[i].alpha = playerTrail[i].life / 20;
          if (playerTrail[i].life <= 0) playerTrail.splice(i, 1);
        }
      }

      function update() {
        if (state !== "play" || paused) return;

        // Input
        const sprint = keys["ShiftLeft"] || keys["ShiftRight"];
        let acc = ACCEL;
        if (turboActive) {
          acc *= 2.5; // Turbo gives massive speed boost
        } else if (sprint && P.stamina > 0) {
          acc *= SPRINT;
          P.stamina -= 0.5;
        }

        if (keys["KeyA"] || keys["ArrowLeft"]) {
          P.vx -= acc;
          P.right = false;
        }
        if (keys["KeyD"] || keys["ArrowRight"]) {
          P.vx += acc;
          P.right = true;
        }

        // Jump with coyote time and jump buffer
        const canJump = (P.grounded || coyoteTime > 0) && P.stamina >= 8;
        const wantsJump = jumpBuffer > 0;
        if (wantsJump && canJump) {
          P.vy = JUMP;
          P.grounded = false;
          P.stamina -= 8;
          coyoteTime = 0; // Consume coyote time
          jumpBuffer = 0; // Consume jump buffer
          // Jump dust effect
          createParticles(P.x + P.w / 2, P.y + P.h, "#ffffff", 5);
        }
        // Countdown buffers
        if (jumpBuffer > 0) jumpBuffer--;
        
        // Running footstep particles (snow puffs)
        if (P.grounded && Math.abs(P.vx) > 2 && Math.random() < 0.2) {
          particles.push({
            x: P.x + P.w / 2 + (P.right ? -8 : 8),
            y: P.y + P.h - 2,
            vx: P.right ? -0.5 : 0.5,
            vy: -0.3 - Math.random() * 0.5,
            life: 0.6,
            decay: 0.03,
            size: 2 + Math.random() * 2,
            color: "#fff",
          });
        }

        // Physics
        P.vx *= FRIC;
        const maxV = turboActive ? MAX_V * 2 : MAX_V;
        if (P.vx > maxV) P.vx = maxV;
        if (P.vx < -maxV) P.vx = -maxV;
        P.vy += GRAV;

        P.x += P.vx;
        P.y += P.vy;

        // Bounds
        if (P.x < 10) {
          P.x = 10;
          P.vx = 0;
        }
        if (P.x + P.w > WORLD_W - 10) {
          P.x = WORLD_W - P.w - 10;
          P.vx = 0;
        }

        // Ground
        const wasGrounded = P.grounded;
        const landingSpeed = P.vy; // Store before resetting - used for Grinch attack detection too
        P.grounded = false;
        if (P.y + P.h >= GROUND) {
          P.y = GROUND - P.h;
          P.vy = 0;
          P.grounded = true;
          // Landing dust effect
          if (!wasGrounded && landingSpeed > 3) {
            const dustCount = Math.min(Math.floor(landingSpeed * 1.5), 12);
            for (let i = 0; i < dustCount; i++) {
              particles.push({
                x: P.x + P.w / 2 + (Math.random() - 0.5) * P.w,
                y: P.y + P.h,
                vx: (Math.random() - 0.5) * 3,
                vy: -Math.random() * 2,
                life: 0.8,
                decay: 0.03,
                size: 2 + Math.random() * 3,
                color: "#e8f0ff",
              });
            }
          }
        }
        // Update coyote time
        if (P.grounded) {
          coyoteTime = COYOTE_FRAMES;
        } else if (wasGrounded) {
          // Just left ground - start coyote countdown
        } else if (coyoteTime > 0) {
          coyoteTime--;
        }

        // Platforms
        for (const pl of platforms) {
          if (pl.moving) {
            pl.x += pl.dir * pl.speed;
            if (pl.x < pl.start - pl.range || pl.x > pl.start + pl.range)
              pl.dir *= -1;
          }
          // Only land on platform if falling down and feet are near platform top
          const feetY = P.y + P.h;
          const wasAbove = feetY - P.vy <= pl.y + 5; // Was above platform last frame
          if (
            P.vy >= 0 &&
            wasAbove &&
            P.x + P.w - 5 > pl.x &&
            P.x + 5 < pl.x + pl.w &&
            feetY >= pl.y &&
            feetY <= pl.y + pl.h + 8
          ) {
            P.y = pl.y - P.h;
            P.vy = 0;
            P.grounded = true;
            if (pl.moving) P.x += pl.dir * pl.speed;
          }
        }

        // Attack thief by jumping on them (like Mario)
        if (thief && !thiefDefeated) {
          const distX = Math.abs(P.x + P.w / 2 - (thief.x + thief.w / 2));
          const distY = P.y - thief.y;
          const horizontalOverlap =
            P.x < thief.x + thief.w && P.x + P.w > thief.x;

          // Hit cooldown to prevent multiple hits in one jump
          if (thiefHitCooldown > 0) thiefHitCooldown--;

          // Player jumping on thief - MUST be falling from above AND have packages
          // Use landingSpeed since P.vy may have been reset by ground collision
          const isAboveThief = distY > -15 && distY < 50;
          const isFallingOnto = landingSpeed > 0.5 || P.vy > 0.5; // Check both - landingSpeed for ground level, P.vy for mid-air
          const isHorizontallyAligned = distX < (P.w + thief.w) / 2 + 15;
          const hasPackages = P.packages > 0; // Can only attack when carrying packages

          if (
            horizontalOverlap &&
            isAboveThief &&
            isFallingOnto &&
            isHorizontallyAligned &&
            hasPackages &&
            thiefHitCooldown === 0
          ) {
            // Damage the thief
            thief.health--;
            thief.hitFlash = 20; // Flash frames instead of squish
            thiefHitCooldown = 60; // Cooldown to prevent instant re-hits
            
            // Big star burst effect
            createParticles(thief.x + thief.w / 2, thief.y, "#ffff00", 15); // Yellow stars
            createParticles(thief.x + thief.w / 2, thief.y, "#4a7c59", 20); // Green particles
            screenShake = 4; // Satisfying screen shake
            P.vy = -8; // Small bounce - player must jump again to attack
            score += 10;
            showScorePopup(thief.x + thief.w / 2, thief.y, "+10", "#ffd93d");

            // Add damage number
            damageNumbers.push({
              x: thief.x + thief.w / 2,
              y: thief.y - 10,
              value: "-1",
              life: 60,
              vy: -2,
            });

            // Push thief far away so player can't just land on them again
            thief.vx = P.x > thief.x ? -8 : 8; // Strong push away
            thief.vy = -3; // Small bounce

            if (thief.health <= 0) {
              // Thief defeated!
              grinchKilledSound.currentTime = 0;
              grinchKilledSound.play();
              createParticles(
                thief.x + thief.w / 2,
                thief.y + thief.h / 2,
                "#4caf50",
                40
              );
              screenShake = 3; // Minimal shake intensity
              score += 50;
              showScorePopup(
                P.x + P.w / 2,
                P.y,
                "+50 GRINCH DEFEATED!",
                "#4caf50"
              );
              showAchievement("üéÑ", "Grinch Defeated!");
              thiefDefeated = true;
              thief = null;
              // Immediately hide Grinch alert
              const thiefAlert = document.getElementById("thief-warning");
              thiefAlert.style.opacity = "0";
              thiefAlert.style.display = "none";
              // Check mission completion
              if (currentMission && currentMission.type === "thief") {
                missionProgress = 1;
                if (missionProgress >= missionTarget) {
                  setTimeout(nextLevel, 500);
                }
              }
            }
          }

          // Thief attacks player (if too close)
          if (
            thief &&
            distX < 35 &&
            P.packages > 0 &&
            thief.stealCooldown === 0
          ) {
            // Push player away when thief steals (no vertical push to prevent auto-jumps)
            window.dispatchEvent(new Event("player-hit"));
            P.stamina -= 5;
            P.vx = P.x > thief.x ? 8 : -8;
          }
        }

        // Update damage numbers
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          dn.y += dn.vy;
          dn.vy *= 0.95;
          dn.life--;
          if (dn.life <= 0) damageNumbers.splice(i, 1);
        }

        // Stamina recovery - faster base regen, still works while walking slowly
        if (P.stamina < 100) {
          // Base regen always happens (slower)
          P.stamina += 0.15;
          // Bonus regen when grounded and moving slowly
          if (P.grounded && Math.abs(P.vx) < 3) {
            P.stamina += 0.35;
          }
          // Extra bonus when completely still
          if (P.grounded && Math.abs(P.vx) < 0.5) {
            P.stamina += 0.3;
          }
          P.stamina = Math.min(100, P.stamina);
        }

        // Warehouse pickup
        if (
          P.x < warehouse.x + warehouse.w &&
          P.x + P.w > warehouse.x &&
          P.y < warehouse.y + warehouse.h &&
          P.y + P.h > warehouse.y
        ) {
          if (P.packages < 3 && warehouse.stock > 0) {
            P.packages++;
            warehouse.stock--;
            score += 2;
            showScorePopup(
              warehouse.x + warehouse.w / 2,
              warehouse.y,
              "+20",
              "#ffd93d"
            );
            createParticles(
              warehouse.x + warehouse.w / 2,
              warehouse.y + warehouse.h / 2,
              "#ffd93d",
              8
            );
            assignDeliveries(); // Re-assign on package pickup
          }
        }

        // Deliveries
        for (const h of houses) {
          if (
            h.needs &&
            P.packages > 0 &&
            P.x < h.x + h.w &&
            P.x + P.w > h.x &&
            P.y + P.h >= h.y
          ) {
            h.needs = false;
            h.done = true;
            P.packages--;
            delivered++;

            // Combo system
            combo++;
            comboTime = 300; // 5 seconds at 60fps
            const comboBonus = Math.min(combo * 2, 20);
            score += 15 + comboBonus;
            totalDeliveries++;
            successfulDeliveries++;

            // Update best combo
            if (combo > bestCombo) {
              bestCombo = combo;
            }

            // Show delivery success animation
            const delSuccess = document.getElementById("delivery-success");
            delSuccess.classList.add("show");
            setTimeout(() => delSuccess.classList.remove("show"), 800);

            // Show score popup
            showScorePopup(
              h.x + h.w / 2,
              h.y,
              `+${150 + comboBonus}`,
              "#4caf50"
            );

            // Achievements
            if (combo === 5) showAchievement("üî•", "5x Combo!");
            if (combo === 10) showAchievement("üî•üî•", "10x Combo Master!");
            if (delivered === 10) showAchievement("üì¶", "10 Deliveries!");
            if (delivered === 25) showAchievement("üèÜ", "25 Deliveries!");

            // Visual feedback
            createParticles(h.x + h.w / 2, h.y, "#4caf50", 20);
            screenShake = 2; // Minimal shake intensity

            warehouse.stock = Math.min(warehouse.stock + 2, 12);

            // Check mission completion
            if (currentMission) {
              missionProgress = currentMission.progress(houses); // Re-calculate progress
              if (missionProgress >= missionTarget) {
                setTimeout(nextLevel, 500);
              } else {
                assignDeliveries();
              }
            } else if (delivered >= needed) {
              setTimeout(nextLevel, 500); // Fallback to old system
            } else {
              assignDeliveries();
            }
          }
        }

        // Combo decay
        if (comboTime > 0) {
          comboTime--;
          if (comboTime === 0) {
            if (combo > 3) {
              showCombo(combo);
            }
            combo = 0;
          }
        }

        // Turbo timer countdown
        if (turboActive) {
          turboTimer--;
          if (turboTimer <= 0) {
            turboActive = false;
          }
        }

        // Power-ups - handle respawn timers
        for (const pu of powerUps) {
          // Handle respawn timer
          if (pu.collected && pu.respawnTimer > 0) {
            pu.respawnTimer--;
            if (pu.respawnTimer <= 0) {
              pu.collected = false; // Respawn!
            }
          }
          
          // Collection check
          if (
            !pu.collected &&
            P.x < pu.x + 20 &&
            P.x + P.w > pu.x &&
            P.y < pu.y + 20 &&
            P.y + P.h > pu.y
          ) {
            pu.collected = true;
            pu.respawnTimer = 600; // Respawn after 10 seconds (600 frames)
            createParticles(
              pu.x + 10,
              pu.y + 10,
              pu.type === "turbo" ? "#4fc3f7" : "#ff4444",
              15
            );
            if (pu.type === "health") {
              if (P.health < 3) {
                P.health++;
                showScorePopup(pu.x + 10, pu.y + 10, "‚ù§Ô∏è +1 HEALTH", "#ff4444");
                showCombo("‚ù§Ô∏è HEALED!");
              } else {
                showScorePopup(pu.x + 10, pu.y + 10, "FULL HP!", "#4caf50");
                pu.collected = false; // Don't consume if already full
                pu.respawnTimer = 0;
              }
            } else if (pu.type === "turbo") {
              turboActive = true;
              turboTimer = 300; // 5 seconds at 60fps
              showScorePopup(pu.x + 10, pu.y + 10, "üöÄ TURBO!", "#4fc3f7");
              showCombo("TURBO MODE!");
            }
          }
        }

        // Obstacle collision
        for (const ob of obstacles) {
          // Check if player overlaps with obstacle
          const playerRight = P.x + P.w;
          const playerBottom = P.y + P.h;
          const obLeft = ob.x;
          const obRight = ob.x + ob.w;
          const obTop = ob.y;
          const obBottom = ob.y + ob.h;
          
          if (playerRight > obLeft && P.x < obRight && playerBottom > obTop && P.y < obBottom) {
            if (ob.type === "iceblock") {
              // Solid barrier - push player out
              const overlapLeft = playerRight - obLeft;
              const overlapRight = obRight - P.x;
              const overlapTop = playerBottom - obTop;
              const overlapBottom = obBottom - P.y;
              
              // Find smallest overlap to determine push direction
              const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
              
              if (minOverlap === overlapTop && P.vy >= 0) {
                // Landing on top
                P.y = obTop - P.h;
                P.vy = 0;
                P.grounded = true;
              } else if (minOverlap === overlapLeft && P.vx > 0) {
                // Hit from left side
                P.x = obLeft - P.w;
                P.vx = 0;
              } else if (minOverlap === overlapRight && P.vx < 0) {
                // Hit from right side
                P.x = obRight;
                P.vx = 0;
              } else if (minOverlap === overlapBottom && P.vy < 0) {
                // Hit from below
                P.y = obBottom;
                P.vy = 0;
              }
            } else {
              // Snowdrift or icewall - slow down and allow landing
              if (P.vy >= 0 && P.y + P.h <= obTop + 10) {
                // Landing on top
                P.y = obTop - P.h;
                P.vy = 0;
                P.grounded = true;
              } else {
                // Side contact - slow down
                P.vx *= 0.6;
              }
            }
          }
        }

        // Thief (Grinch)
        if (thiefSpawnTime > 0) {
          thiefSpawnTime--;
          if (thiefSpawnTime === 0 && !thiefDefeated) {
            // Spawn thief away from player
            thief = {
              x: P.x + (Math.random() > 0.5 ? 400 : -400),
              y: GROUND - 40,
              w: 28,
              h: 40,
              vx: 0,
              vy: 0,
              speed: 2 + level * 0.3,
              health: 2 + level,
              maxHealth: 2 + level,
              right: true,
              grounded: false,
              stealCooldown: 0,
              suspicious: false,
              suspiciousTime: 0,
              lastSeen: 0,
              hitFlash: 0, // Flash when hit
            };
            // Clamp to world bounds
            if (thief.x < 50) thief.x = 50;
            if (thief.x > WORLD_W - 50) thief.x = WORLD_W - 50;
          }
        }

        if (thief && !thiefDefeated) {
          // Thief physics
          thief.vy += GRAV;
          thief.x += thief.vx;
          thief.y += thief.vy;
          
          // Decay hit flash
          if (thief.hitFlash > 0) {
            thief.hitFlash--;
          }

          // Ground collision
          thief.grounded = false;
          if (thief.y + thief.h >= GROUND) {
            thief.y = GROUND - thief.h;
            thief.vy = 0;
            thief.grounded = true;
          }

          // Platform collision for thief
          for (const pl of platforms) {
            if (
              thief.vy >= 0 &&
              thief.x + thief.w > pl.x &&
              thief.x < pl.x + pl.w &&
              thief.y + thief.h >= pl.y &&
              thief.y + thief.h <= pl.y + pl.h + 12
            ) {
              thief.y = pl.y - thief.h;
              thief.vy = 0;
              thief.grounded = true;
            }
          }

          // Thief AI - Simple and predictable behavior
          const distToPlayer = Math.abs(P.x - thief.x);
          const heightDiff = P.y - thief.y; // Negative if player is above
          
          // Apply friction to slow down
          thief.vx *= 0.9;
          
          // Only chase if player has packages and is nearby
          if (P.packages > 0 && distToPlayer < 400) {
            thief.suspicious = true;
            thief.suspiciousTime = 60;
            
            // Move toward player at steady speed
            if (P.x > thief.x + 20) {
              thief.vx = thief.speed;
              thief.right = true;
            } else if (P.x < thief.x - 20) {
              thief.vx = -thief.speed;
              thief.right = false;
            }
            
            // Jump to chase player if they're above (on platform) or to avoid obstacles
            if (thief.grounded) {
              // Jump if player is significantly above
              if (heightDiff < -50 && distToPlayer < 150) {
                thief.vy = -10; // Jump!
                thief.grounded = false;
              }
              // Random jump while chasing to be more aggressive
              else if (Math.random() < 0.01 && distToPlayer < 200) {
                thief.vy = -8; // Smaller hop
                thief.grounded = false;
              }
            }
          } else if (P.packages === 0) {
            // No packages - Grinch ignores player completely
            thief.suspicious = false;
            thief.vx *= 0.8; // Slow to a stop
          } else {
            // Player too far - wander slowly
            thief.suspicious = false;
            if (thief.grounded && Math.abs(thief.vx) < 0.5) {
              // Occasionally pick a direction to wander
              if (Math.random() > 0.99) {
                thief.vx = (Math.random() > 0.5 ? 1 : -1) * thief.speed * 0.4;
                thief.right = thief.vx > 0;
              }
            }
            // Occasional idle hop while wandering
            if (thief.grounded && Math.random() < 0.003) {
              thief.vy = -6;
              thief.grounded = false;
            }
          }

          // Steal packages from player
          if (thief.stealCooldown > 0) thief.stealCooldown--;

          if (
            distToPlayer < 40 &&
            P.packages > 0 &&
            thief.stealCooldown === 0
          ) {
            P.packages--;
            thief.stealCooldown = 180; // 3 second cooldown
            createParticles(
              thief.x + thief.w / 2,
              thief.y + thief.h / 2,
              "#ff4444",
              15
            );
            screenShake = 2; // Minimal shake intensity
            score = Math.max(0, score - 5);
            combo = 0; // Reset combo
            comboTime = 0;
            assignDeliveries(); // Re-assign if package stolen
          }

          // Suspicious behavior timer
          if (thief.suspiciousTime > 0) {
            thief.suspiciousTime--;
          } else {
            thief.suspicious = false;
          }

          // Bounds
          if (thief.x < 10) {
            thief.x = 10;
            thief.vx = 0;
          }
          if (thief.x + thief.w > WORLD_W - 10) {
            thief.x = WORLD_W - thief.w - 10;
            thief.vx = 0;
          }
        }

        // Update particles
        updateParticles();

        // Update player trail
        updateTrail();

        // Update score popups
        for (let i = scorePopups.length - 1; i >= 0; i--) {
          scorePopups[i].y += scorePopups[i].vy;
          scorePopups[i].vy *= 0.95;
          scorePopups[i].life--;
          if (scorePopups[i].life <= 0) scorePopups.splice(i, 1);
        }

        // Update stats
        if (gameStartTime > 0) {
          const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
          document.getElementById("game-time").textContent = gameTime;
          document.getElementById("best-combo").textContent = bestCombo;
          const accuracy =
            totalDeliveries > 0
              ? Math.round((successfulDeliveries / totalDeliveries) * 100)
              : 100;
          document.getElementById("accuracy").textContent = accuracy;
        }

        // Screen shake decay
        if (screenShake > 0) screenShake--;

        // Ice
        for (const ice of iceBlocks) {
          ice.y += ice.speed;
          ice.rot += 0.05;

          if (ice.y > H + 50) {
            ice.y = -50 - Math.random() * 300;
            ice.x = Math.random() * WORLD_W;
          }

          // Collision with ice - damages health
          if (
            P.x < ice.x + ice.size &&
            P.x + P.w > ice.x &&
            P.y < ice.y + ice.size &&
            P.y + P.h > ice.y
          ) {
            P.health--; // Lose a heart
            P.vx = P.x > ice.x ? 5 : -5;
            P.vy = -8;
            combo = 0; // Reset combo on hit
            comboTime = 0;
            createParticles(
              ice.x + ice.size / 2,
              ice.y + ice.size / 2,
              "#ff4444",
              20
            );
            screenShake = 5;
            ice.y = -100 - Math.random() * 200;
            ice.x = Math.random() * WORLD_W;
            
            // Flash screen red briefly
            showCombo("‚ù§Ô∏è -1 HEALTH!");

            if (P.health <= 0) {
              P.health = 0;
              endGame();
            }
          }
        }

        // Snow - improved falling effect with varied sizes and wind
        for (const s of snow) {
          s.y += s.s;
          // Wind effect varies by height - upper snow moves more
          const windStrength = 0.3 + (1 - s.y / H) * 0.2;
          s.x += Math.sin(Date.now() / 800 + s.x * 0.5) * windStrength;
          // Slight wobble
          s.x += Math.cos(Date.now() / 400 + s.y) * 0.1;
          if (s.y > H) {
            s.y = -5 - Math.random() * 20;
            s.x = Math.random() * WORLD_W;
            s.r = 1 + Math.random() * 3; // Vary size on respawn
            s.s = 0.3 + Math.random() * 1.2; // Vary speed
          }
        }

        // Camera - ensure full screen is always visible
        const target = P.x - W / 2 + P.w / 2;

        // Smoothly move camera towards target
        camX += (target - camX) * 0.1;

        // Strict bounds checking
        const minCamX = 0;
        const maxCamX = Math.max(0, WORLD_W - W);

        camX = Math.max(minCamX, Math.min(camX, maxCamX));

        updateHUD();
      }

      function draw() {
        // Sky with aurora effect
        const sky = ctx.createLinearGradient(0, 0, 0, H);
        sky.addColorStop(0, "#0a0a20");
        sky.addColorStop(0.3, "#1a1a3e");
        sky.addColorStop(0.7, "#1a2a4a");
        sky.addColorStop(1, "#2a3a5a");
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, W, H);

        // Aurora borealis effect
        const time = Date.now() / 1000;
        ctx.save();
        ctx.globalAlpha = 0.15;
        for (let i = 0; i < 3; i++) {
          const waveOffset = Math.sin(time * 0.5 + i) * 30;
          const grad = ctx.createLinearGradient(0, 50 + i * 20, W, 100 + i * 20);
          grad.addColorStop(0, "transparent");
          grad.addColorStop(0.3, i === 0 ? "#00ff88" : i === 1 ? "#00ffcc" : "#88ffcc");
          grad.addColorStop(0.7, i === 0 ? "#00ccff" : i === 1 ? "#00ff88" : "#00ffcc");
          grad.addColorStop(1, "transparent");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(0, 60 + waveOffset);
          for (let x = 0; x <= W; x += 20) {
            ctx.lineTo(x, 60 + Math.sin(x * 0.01 + time + i) * 15 + waveOffset);
          }
          ctx.lineTo(W, 120);
          ctx.lineTo(0, 120);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        // Stars (twinkling) - more stars with varied sizes
        for (let i = 0; i < 60; i++) {
          const twinkle = 0.2 + Math.sin(time * 2 + i * 1.5) * 0.3;
          const size = 0.5 + (i % 3) * 0.5;
          ctx.fillStyle = `rgba(255,255,255,${twinkle})`;
          ctx.beginPath();
          ctx.arc(
            (i * 61 + Math.sin(i) * 20) % W,
            (i * 37) % (H * 0.4),
            size + Math.sin(time + i) * 0.3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        // Distant mountains (parallax layer 1 - slowest)
        ctx.fillStyle = "#1a2040";
        ctx.beginPath();
        ctx.moveTo(0, H * 0.7);
        for (let x = 0; x <= W + 100; x += 100) {
          const worldX = x + camX * 0.1; // Slow parallax
          const peakHeight = 80 + Math.sin(worldX * 0.005) * 40 + Math.cos(worldX * 0.003) * 30;
          ctx.lineTo(x, H * 0.7 - peakHeight);
        }
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();

        // Mid mountains (parallax layer 2)
        ctx.fillStyle = "#252850";
        ctx.beginPath();
        ctx.moveTo(0, H * 0.75);
        for (let x = 0; x <= W + 80; x += 80) {
          const worldX = x + camX * 0.25;
          const peakHeight = 60 + Math.sin(worldX * 0.008) * 35 + Math.cos(worldX * 0.012) * 25;
          ctx.lineTo(x, H * 0.75 - peakHeight);
        }
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();

        // Near hills with trees (parallax layer 3)
        ctx.fillStyle = "#303060";
        ctx.beginPath();
        ctx.moveTo(0, GROUND - 30);
        for (let x = 0; x <= W + 60; x += 60) {
          const worldX = x + camX * 0.4;
          const hillHeight = 30 + Math.sin(worldX * 0.015) * 20;
          ctx.lineTo(x, GROUND - hillHeight);
        }
        ctx.lineTo(W, GROUND);
        ctx.lineTo(0, GROUND);
        ctx.closePath();
        ctx.fill();

        // Distant pine trees silhouettes
        ctx.fillStyle = "#202040";
        for (let i = 0; i < 15; i++) {
          const treeX = ((i * 200 + 50) - camX * 0.3) % (W + 200) - 100;
          const treeH = 40 + (i % 3) * 15;
          ctx.beginPath();
          ctx.moveTo(treeX, GROUND - 50);
          ctx.lineTo(treeX - 15, GROUND - 50 + treeH);
          ctx.lineTo(treeX + 15, GROUND - 50 + treeH);
          ctx.closePath();
          ctx.fill();
        }

        // Moon (with glow)
        const moonGrad = ctx.createRadialGradient(
          W - 80,
          60,
          0,
          W - 80,
          60,
          50
        );
        moonGrad.addColorStop(0, "#fffde8");
        moonGrad.addColorStop(0.4, "#fffde8");
        moonGrad.addColorStop(0.7, "rgba(255,253,232,0.3)");
        moonGrad.addColorStop(1, "rgba(255,253,232,0)");
        ctx.fillStyle = moonGrad;
        ctx.beginPath();
        ctx.arc(W - 80, 60, 50, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fffde8";
        ctx.beginPath();
        ctx.arc(W - 80, 60, 28, 0, Math.PI * 2);
        ctx.fill();
        // Moon craters
        ctx.fillStyle = "rgba(200,200,180,0.3)";
        ctx.beginPath();
        ctx.arc(W - 90, 55, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(W - 72, 68, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        // Apply camera transformation
        ctx.translate(-camX, 0);

        // Ground with snow texture
        // Main snow layer
        const groundGrad = ctx.createLinearGradient(0, GROUND, 0, GROUND + 50);
        groundGrad.addColorStop(0, "#ffffff");
        groundGrad.addColorStop(0.2, "#f0f5ff");
        groundGrad.addColorStop(0.5, "#e0e8f0");
        groundGrad.addColorStop(1, "#c0d0e0");
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, GROUND, WORLD_W, 50);
        
        // Snow drifts along the ground (wavy top edge)
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(0, GROUND);
        for (let x = 0; x <= WORLD_W; x += 30) {
          const driftH = 3 + Math.sin(x * 0.02) * 2 + Math.cos(x * 0.05) * 1.5;
          ctx.lineTo(x, GROUND - driftH);
        }
        ctx.lineTo(WORLD_W, GROUND + 5);
        ctx.lineTo(0, GROUND + 5);
        ctx.closePath();
        ctx.fill();
        
        // Sparkle effects on snow
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        for (let i = 0; i < 30; i++) {
          const sparkleX = (i * 101 + Math.sin(Date.now() / 500 + i) * 5) % WORLD_W;
          const sparkleY = GROUND + 2 + (i % 5) * 3;
          const sparkleSize = 1 + Math.sin(Date.now() / 300 + i * 2) * 0.5;
          if (sparkleSize > 0.8) {
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Background buildings
        ctx.fillStyle = "#2c3e50";
        for (let x = 200; x < WORLD_W; x += 200) {
          const bh = 80 + Math.sin(x) * 40;
          ctx.fillRect(x, GROUND - bh, 100, bh);
          ctx.fillStyle = "#34495e";
          ctx.fillRect(x, GROUND - bh, 100, 10);
          ctx.fillStyle = "#2c3e50";
        }

        // Warehouse
        if (warehouse) {
          ctx.fillStyle = "#8b7355";
          ctx.fillRect(warehouse.x, warehouse.y, warehouse.w, warehouse.h);
          ctx.fillStyle = "#ffd93d";
          ctx.fillRect(warehouse.x + 40, warehouse.y + 30, 40, 60);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(
            "WAREHOUSE",
            warehouse.x + warehouse.w / 2,
            warehouse.y - 5
          );
          ctx.fillText(
            "[" + warehouse.stock + "]",
            warehouse.x + warehouse.w / 2,
            warehouse.y + 60
          );
        }

        // Houses
        for (const h of houses) {
          // Body
          ctx.fillStyle = "#ddd";
          ctx.fillRect(h.x, h.y, h.w, h.h);

          // Roof
          ctx.fillStyle = h.color;
          ctx.beginPath();
          ctx.moveTo(h.x - 8, h.y);
          ctx.lineTo(h.x + h.w / 2, h.y - 30);
          ctx.lineTo(h.x + h.w + 8, h.y);
          ctx.closePath();
          ctx.fill();

          // Snow on roof
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.moveTo(h.x - 8, h.y + 2);
          ctx.lineTo(h.x + h.w / 2, h.y - 25);
          ctx.lineTo(h.x + h.w + 8, h.y + 2);
          ctx.closePath();
          ctx.fill();

          // Door
          ctx.fillStyle = "#654321";
          ctx.fillRect(h.x + h.w / 2 - 10, h.y + h.h - 35, 20, 35);

          // Windows
          ctx.fillStyle = "#ffeaa7";
          ctx.fillRect(h.x + 10, h.y + 15, 18, 18);
          ctx.fillRect(h.x + h.w - 28, h.y + 15, 18, 18);

          // Delivery marker
          if (h.needs) {
            const pulse = 0.7 + Math.sin(Date.now() / 150) * 0.3;
            ctx.fillStyle = "rgba(255,100,100," + pulse + ")";
            ctx.beginPath();
            ctx.moveTo(h.x + h.w / 2, h.y - 45);
            ctx.lineTo(h.x + h.w / 2 - 12, h.y - 65);
            ctx.lineTo(h.x + h.w / 2 + 12, h.y - 65);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.font = "14px sans-serif";
            ctx.fillText("üì¶", h.x + h.w / 2, h.y - 50);
          }

          // Mission target indicator (e.g., a blue ring)
          if (h.missionTarget && !h.done) {
            const ringPulse = 0.5 + Math.sin(Date.now() / 150) * 0.5;
            ctx.strokeStyle = `rgba(79, 195, 247, ${ringPulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(h.x + h.w / 2, h.y + h.h / 2, h.w / 2 + 5, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Done checkmark
          if (h.done) {
            ctx.fillStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(h.x + h.w / 2, h.y - 40, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.font = "14px sans-serif";
            ctx.fillText("‚úì", h.x + h.w / 2, h.y - 36);
          }
        }

        // Platforms
        for (const pl of platforms) {
          const g = ctx.createLinearGradient(pl.x, pl.y, pl.x, pl.y + pl.h);
          g.addColorStop(0, "#b3e5fc");
          g.addColorStop(1, "#4fc3f7");
          ctx.fillStyle = g;
          ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
          ctx.fillStyle = "#fff";
          ctx.fillRect(pl.x, pl.y, pl.w, 3);
        }

        // Obstacles (snowdrifts, ice walls, and solid ice blocks)
        for (const obs of obstacles) {
          if (obs.type === "snowdrift") {
            // Snowdrift - a mound of snow (slows movement)
            ctx.fillStyle = "#e8f5ff";
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.y + obs.h);
            ctx.quadraticCurveTo(obs.x + obs.w / 4, obs.y, obs.x + obs.w / 2, obs.y);
            ctx.quadraticCurveTo(obs.x + obs.w * 0.75, obs.y, obs.x + obs.w, obs.y + obs.h);
            ctx.closePath();
            ctx.fill();
            // Snow texture
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(obs.x + obs.w * 0.3, obs.y + obs.h * 0.4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obs.x + obs.w * 0.6, obs.y + obs.h * 0.3, 5, 0, Math.PI * 2);
            ctx.fill();
          } else if (obs.type === "icewall") {
            // Ice wall - translucent blue block (slows movement)
            const g = ctx.createLinearGradient(obs.x, obs.y, obs.x + obs.w, obs.y);
            g.addColorStop(0, "rgba(100,200,255,0.8)");
            g.addColorStop(0.5, "rgba(200,240,255,0.9)");
            g.addColorStop(1, "rgba(100,200,255,0.8)");
            ctx.fillStyle = g;
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            // Ice cracks
            ctx.strokeStyle = "rgba(255,255,255,0.6)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(obs.x + 5, obs.y + 5);
            ctx.lineTo(obs.x + obs.w / 2, obs.y + obs.h / 2);
            ctx.lineTo(obs.x + obs.w - 5, obs.y + 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(obs.x + obs.w / 2, obs.y + obs.h / 2);
            ctx.lineTo(obs.x + 10, obs.y + obs.h - 5);
            ctx.stroke();
            // Highlight
            ctx.fillStyle = "rgba(255,255,255,0.4)";
            ctx.fillRect(obs.x + 3, obs.y + 3, obs.w / 3, obs.h - 6);
          } else if (obs.type === "iceblock") {
            // Solid ice block barrier - blocks movement completely
            const g = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y + obs.h);
            g.addColorStop(0, "#87ceeb");
            g.addColorStop(0.3, "#b0e0e6");
            g.addColorStop(0.7, "#87ceeb");
            g.addColorStop(1, "#5f9ea0");
            ctx.fillStyle = g;
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            
            // Frozen texture/details
            ctx.strokeStyle = "rgba(255,255,255,0.7)";
            ctx.lineWidth = 2;
            ctx.strokeRect(obs.x + 2, obs.y + 2, obs.w - 4, obs.h - 4);
            
            // Ice crystal patterns
            ctx.strokeStyle = "rgba(200,240,255,0.8)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(obs.x + obs.w / 2, obs.y + 5);
            ctx.lineTo(obs.x + obs.w / 2, obs.y + obs.h - 5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(obs.x + 5, obs.y + obs.h / 2);
            ctx.lineTo(obs.x + obs.w - 5, obs.y + obs.h / 2);
            ctx.stroke();
            
            // Diagonal cracks
            ctx.beginPath();
            ctx.moveTo(obs.x + 5, obs.y + 5);
            ctx.lineTo(obs.x + obs.w / 3, obs.y + obs.h / 3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(obs.x + obs.w - 5, obs.y + obs.h - 5);
            ctx.lineTo(obs.x + obs.w * 0.66, obs.y + obs.h * 0.66);
            ctx.stroke();
            
            // Top shine
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillRect(obs.x + 3, obs.y + 3, obs.w - 6, 6);
            
            // Icicles at bottom
            ctx.fillStyle = "#b0e0e6";
            for (let i = 0; i < 3; i++) {
              const ix = obs.x + 5 + i * (obs.w - 10) / 2;
              ctx.beginPath();
              ctx.moveTo(ix, obs.y + obs.h);
              ctx.lineTo(ix + 4, obs.y + obs.h);
              ctx.lineTo(ix + 2, obs.y + obs.h + 8 + Math.random() * 4);
              ctx.closePath();
              ctx.fill();
            }
          }
        }

        // Snow particles
        ctx.fillStyle = "rgba(255,255,255,0.6)";
        for (const s of snow) {
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fill();
        }

        // Ice
        for (const ice of iceBlocks) {
          ctx.save();
          ctx.translate(ice.x + ice.size / 2, ice.y + ice.size / 2);
          ctx.rotate(ice.rot);
          ctx.fillStyle = "rgba(173,216,230,0.85)";
          ctx.beginPath();
          ctx.moveTo(0, -ice.size / 2);
          ctx.lineTo(ice.size / 2, 0);
          ctx.lineTo(0, ice.size / 2);
          ctx.lineTo(-ice.size / 2, 0);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }

        // Power-ups
        for (const pu of powerUps) {
          // Show faded version when respawning
          if (pu.collected && pu.respawnTimer > 0) {
            // Show faded outline to indicate where powerup will respawn
            const fadeProgress = 1 - (pu.respawnTimer / 600);
            if (fadeProgress > 0.5) { // Only show when more than halfway respawned
              ctx.save();
              ctx.translate(pu.x + 15, pu.y + 15);
              ctx.globalAlpha = (fadeProgress - 0.5) * 0.5; // Fade in
              ctx.strokeStyle = pu.type === "health" ? "#ff4444" : "#4fc3f7";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.restore();
            }
          } else if (!pu.collected) {
            pu.rot += 0.03;
            ctx.save();
            ctx.translate(pu.x + 15, pu.y + 15);
            ctx.rotate(pu.rot);
            const pulse = 0.85 + Math.sin(Date.now() / 200) * 0.15;
            ctx.globalAlpha = pulse;
            // Different colors for each powerup type
            if (pu.type === "health") {
              ctx.fillStyle = "#ff4444"; // Red for health
            } else {
              // Turbo - blue
              ctx.fillStyle = "#4fc3f7";
            }
            // Circle
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI * 2);
            ctx.fill();
            // White border
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.stroke();
            // Icons
            ctx.fillStyle = "#fff";
            ctx.font = "bold 18px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let icon = "‚ù§Ô∏è"; // Heart for health
            if (pu.type === "turbo") icon = "üöÄ"; // Rocket for turbo
            ctx.fillText(icon, 0, 1);
            ctx.restore();
          }
        }

        // Grinch (draw before player so player appears on top)
        if (thief && !thiefDefeated) {
          const tx = thief.x,
            ty = thief.y;

          // Shadow
          ctx.fillStyle = "rgba(0,100,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            tx + thief.w / 2,
            GROUND,
            thief.w * 0.6,
            6,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // Evil glow effect
          if (thief.suspicious) {
            const glow = ctx.createRadialGradient(
              tx + thief.w / 2,
              ty + thief.h / 2,
              0,
              tx + thief.w / 2,
              ty + thief.h / 2,
              50
            );
            glow.addColorStop(0, "rgba(0,200,0,0.4)");
            glow.addColorStop(1, "rgba(0,200,0,0)");
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(tx + thief.w / 2, ty + thief.h / 2, 50, 0, Math.PI * 2);
            ctx.fill();
          }

          // === THE GRINCH ===
          
          // Hit flash effect when stomped
          const isFlashing = thief.hitFlash > 0;
          if (isFlashing && thief.hitFlash % 4 < 2) {
            // Blink white every few frames
            ctx.globalAlpha = 0.7;
          }
          
          // Furry green body (flash white when hit)
          ctx.fillStyle = isFlashing ? "#ffffff" : "#4a7c59";
          ctx.fillRect(tx + 2, ty + 14, thief.w - 4, thief.h - 22);
          
          // Fur texture on body
          ctx.fillStyle = "#3d6b4a";
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(tx + 6 + i * 5, ty + 20 + (i % 2) * 8, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // Legs (skinny green)
          const walkOffset =
            Math.abs(thief.vx) > 0.3 ? Math.sin(Date.now() / 100) * 3 : 0;
          ctx.fillStyle = "#4a7c59";
          ctx.fillRect(tx + 6 + walkOffset, ty + thief.h - 14, 5, 14);
          ctx.fillRect(tx + thief.w - 11 - walkOffset, ty + thief.h - 14, 5, 14);

          // Grinch feet (big and hairy)
          ctx.fillStyle = "#3d6b4a";
          ctx.beginPath();
          ctx.ellipse(tx + 8 + walkOffset, ty + thief.h - 2, 8, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(tx + thief.w - 8 - walkOffset, ty + thief.h - 2, 8, 4, 0, 0, Math.PI * 2);
          ctx.fill();

          // Grinch head (larger, furry)
          ctx.fillStyle = "#4a7c59";
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2, ty + 8, 12, 0, Math.PI * 2);
          ctx.fill();
          
          // Fur tufts on head - more wild and spiky
          ctx.fillStyle = "#3d6b4a";
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2 - 10, ty, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2 + 10, ty, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2, ty - 4, 4, 0, Math.PI * 2);
          ctx.fill();
          // Extra spiky tufts
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 - 12, ty - 2);
          ctx.lineTo(tx + thief.w / 2 - 8, ty + 4);
          ctx.lineTo(tx + thief.w / 2 - 14, ty + 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 + 12, ty - 2);
          ctx.lineTo(tx + thief.w / 2 + 8, ty + 4);
          ctx.lineTo(tx + thief.w / 2 + 14, ty + 2);
          ctx.fill();

          // Evil slanted eyebrows (tiger-like, very angry)
          ctx.strokeStyle = "#2d4a35";
          ctx.lineWidth = 4;
          ctx.lineCap = "round";
          // Left eyebrow - slanted down toward center
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 - 12, ty + 1);
          ctx.lineTo(tx + thief.w / 2 - 3, ty + 6);
          ctx.stroke();
          // Right eyebrow - slanted down toward center
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 + 12, ty + 1);
          ctx.lineTo(tx + thief.w / 2 + 3, ty + 6);
          ctx.stroke();

          // Yellow eyes (sinister, narrow slits like a tiger)
          const eyeDir = thief.right ? 2 : -2;
          // Eye whites (narrow ovals)
          ctx.fillStyle = "#ffeb3b";
          ctx.save();
          ctx.translate(tx + thief.w / 2 + eyeDir - 6, ty + 9);
          ctx.scale(1, 0.6);
          ctx.beginPath();
          ctx.arc(0, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.save();
          ctx.translate(tx + thief.w / 2 + eyeDir + 6, ty + 9);
          ctx.scale(1, 0.6);
          ctx.beginPath();
          ctx.arc(0, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Black slit pupils (cat/tiger-like)
          ctx.fillStyle = "#111";
          ctx.fillRect(tx + thief.w / 2 + eyeDir - 7, ty + 6, 2, 6);
          ctx.fillRect(tx + thief.w / 2 + eyeDir + 5, ty + 6, 2, 6);
          
          // Red glint in eyes
          ctx.fillStyle = "#ff0000";
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2 + eyeDir - 7, ty + 7, 1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2 + eyeDir + 5, ty + 7, 1, 0, Math.PI * 2);
          ctx.fill();

          // Wrinkle lines under eyes (mean look)
          ctx.strokeStyle = "#3d6b4a";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 - 10, ty + 12);
          ctx.lineTo(tx + thief.w / 2 - 6, ty + 11);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 + 10, ty + 12);
          ctx.lineTo(tx + thief.w / 2 + 6, ty + 11);
          ctx.stroke();

          // Mean grin (wide, devious smile)
          ctx.strokeStyle = "#1a1a1a";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 - 10, ty + 16);
          ctx.quadraticCurveTo(tx + thief.w / 2, ty + 22, tx + thief.w / 2 + 10, ty + 16);
          ctx.stroke();
          
          // Sharp teeth in the grin
          ctx.fillStyle = "#fff";
          for (let i = -3; i <= 3; i++) {
            if (i !== 0) {
              ctx.beginPath();
              ctx.moveTo(tx + thief.w / 2 + i * 3 - 1, ty + 17);
              ctx.lineTo(tx + thief.w / 2 + i * 3 + 1, ty + 17);
              ctx.lineTo(tx + thief.w / 2 + i * 3, ty + 20);
              ctx.closePath();
              ctx.fill();
            }
          }
          
          // Pointy nose (like the Grinch)
          ctx.fillStyle = "#4a7c59";
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2, ty + 8);
          ctx.lineTo(tx + thief.w / 2 - 4, ty + 15);
          ctx.lineTo(tx + thief.w / 2 + 4, ty + 15);
          ctx.closePath();
          ctx.fill();
          // Nostril
          ctx.fillStyle = "#2d4a35";
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2, ty + 14, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Grinch fingers (long and creepy)
          ctx.fillStyle = "#4a7c59";
          const armOffset = Math.sin(Date.now() / 150) * 2;
          // Left arm
          ctx.save();
          ctx.translate(tx + 2, ty + 18);
          ctx.rotate(-0.3 + armOffset * 0.05);
          ctx.fillRect(-2, 0, 5, 14);
          // Long fingers
          ctx.fillRect(-4, 12, 3, 8);
          ctx.fillRect(-1, 13, 3, 7);
          ctx.fillRect(2, 12, 3, 8);
          ctx.restore();
          
          // Right arm
          ctx.save();
          ctx.translate(tx + thief.w - 2, ty + 18);
          ctx.rotate(0.3 - armOffset * 0.05);
          ctx.fillRect(-3, 0, 5, 14);
          ctx.fillRect(-4, 12, 3, 8);
          ctx.fillRect(-1, 13, 3, 7);
          ctx.fillRect(2, 12, 3, 8);
          ctx.restore();
          
          // Santa hat (stolen!) - tip trails behind when moving with wave animation
          const grinchMoving = Math.abs(thief.vx) > 0.5;
          const grinchSpeed = Math.abs(thief.vx);
          const grinchWaveTime = Date.now() / 100;
          const grinchWaveAmp = grinchMoving ? Math.min(grinchSpeed * 0.6, 3) : 0;
          const grinchWaveOffset = Math.sin(grinchWaveTime) * grinchWaveAmp;
          const grinchHatOffset = grinchMoving ? (thief.vx > 0 ? -10 - grinchWaveAmp : 10 + grinchWaveAmp) : 0;
          const grinchHatTipY = grinchMoving ? -22 + grinchWaveOffset : -24;
          
          ctx.fillStyle = "#c62828";
          ctx.beginPath();
          ctx.moveTo(tx + thief.w / 2 - 10, ty - 4);
          ctx.lineTo(tx + thief.w / 2 + 10, ty - 4);
          if (grinchMoving) {
            ctx.quadraticCurveTo(
              tx + thief.w / 2 + grinchHatOffset * 0.5, ty - 14 + grinchWaveOffset * 0.5,
              tx + thief.w / 2 + grinchHatOffset, ty + grinchHatTipY
            );
          } else {
            ctx.lineTo(tx + thief.w / 2 + grinchHatOffset, ty + grinchHatTipY);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#fff";
          ctx.fillRect(tx + thief.w / 2 - 12, ty - 6, 24, 5);
          ctx.beginPath();
          ctx.arc(tx + thief.w / 2 + grinchHatOffset, ty + grinchHatTipY, 4, 0, Math.PI * 2); // Pom-pom follows tip
          ctx.fill();
          
          // Reset alpha after squish effect
          ctx.globalAlpha = 1.0;

          // Health bar (always show when damaged)
          if (thief.health < thief.maxHealth) {
            ctx.fillStyle = "#333";
            ctx.fillRect(tx, ty - 8, thief.w, 4);
            ctx.fillStyle = "#4caf50";
            ctx.fillRect(
              tx,
              ty - 8,
              thief.w * (thief.health / thief.maxHealth),
              4
            );
            // Health text
            ctx.fillStyle = "#fff";
            ctx.font = "bold 10px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
              `${thief.health}/${thief.maxHealth}`,
              tx + thief.w / 2,
              ty - 10
            );
          }

          // Suspicious indicator (exclamation mark)
          if (thief.suspicious) {
            ctx.fillStyle = "#ffd93d";
            ctx.font = "bold 16px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
              "!",
              tx + thief.w / 2,
              ty - (thief.health < thief.maxHealth ? 25 : 15)
            );
          }
        }

        // Draw damage numbers (after camera transform is restored)
        for (const dn of damageNumbers) {
          ctx.save();
          ctx.globalAlpha = dn.life / 60;
          ctx.fillStyle = "#ff4444";
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 3;
          ctx.strokeText(dn.value, dn.x - camX, dn.y);
          ctx.fillText(dn.value, dn.x - camX, dn.y);
          ctx.restore();
        }

        // Particles
        drawParticles();

        // Player trail effect
        for (let i = 0; i < playerTrail.length; i++) {
          const t = playerTrail[i];
          ctx.save();
          ctx.globalAlpha = t.alpha * 0.3;
          ctx.fillStyle = "#4fc3f7";
          ctx.beginPath();
          ctx.arc(t.x, t.y, 3 + (1 - t.alpha) * 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Player - simple visible character
        const px = P.x,
          py = P.y;

        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(px + P.w / 2, GROUND, P.w * 0.8, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // === SANTA ON SLEIGH ===
        // Save context and flip if facing left
        ctx.save();
        if (!P.right) {
          // Flip horizontally around the center of the player
          ctx.translate(px + P.w / 2, 0);
          ctx.scale(-1, 1);
          ctx.translate(-(px + P.w / 2), 0);
        }
        
        // Sleigh runners (curved at front)
        ctx.fillStyle = "#8b4513";
        ctx.fillRect(px, py + P.h - 6, P.w + 10, 4);
        ctx.fillRect(px - 5, py + P.h - 10, 4, 8);
        // Curved front runner
        ctx.beginPath();
        ctx.arc(px - 5, py + P.h - 10, 6, Math.PI * 0.5, Math.PI * 1.5);
        ctx.fill();
        
        // Sleigh body (red)
        ctx.fillStyle = "#c62828";
        ctx.fillRect(px + 2, py + P.h - 24, P.w + 4, 18);
        // Sleigh front curve
        ctx.beginPath();
        ctx.arc(px, py + P.h - 15, 12, Math.PI * 0.5, Math.PI * 1.5);
        ctx.fill();
        
        // Gold trim on sleigh
        ctx.fillStyle = "#ffd700";
        ctx.fillRect(px + 2, py + P.h - 24, P.w + 4, 3);
        ctx.fillRect(px + 2, py + P.h - 9, P.w + 4, 3);
        
        // Sleigh interior (darker)
        ctx.fillStyle = "#8b0000";
        ctx.fillRect(px + 6, py + P.h - 21, P.w - 6, 12);
        
        // Present sack in back of sleigh
        ctx.fillStyle = "#c0392b";
        ctx.beginPath();
        ctx.arc(px + P.w - 5, py + P.h - 28, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffd700";
        ctx.beginPath();
        ctx.moveTo(px + P.w - 10, py + P.h - 38);
        ctx.lineTo(px + P.w, py + P.h - 38);
        ctx.lineTo(px + P.w - 5, py + P.h - 32);
        ctx.closePath();
        ctx.fill();
        
        // Packages visible in sack
        if (P.packages > 0) {
          for (let i = 0; i < Math.min(P.packages, 3); i++) {
            ctx.fillStyle = ["#4fc3f7", "#4caf50", "#ff9800"][i];
            ctx.fillRect(px + P.w - 12 + i * 5, py + P.h - 35 + i * 3, 6, 5);
            ctx.fillStyle = "#ffd700";
            ctx.fillRect(px + P.w - 10 + i * 5, py + P.h - 33 + i * 3, 2, 5);
          }
        }
        
        // Santa's body (sitting in sleigh)
        ctx.fillStyle = "#c62828";
        ctx.fillRect(px + 8, py + 8, 20, 28);
        
        // Santa's belly
        ctx.fillStyle = "#c62828";
        ctx.beginPath();
        ctx.arc(px + 18, py + 25, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // White fur trim
        ctx.fillStyle = "#fff";
        ctx.fillRect(px + 8, py + 32, 20, 4);
        ctx.fillRect(px + 6, py + 8, 24, 4);
        
        // Belt
        ctx.fillStyle = "#333";
        ctx.fillRect(px + 7, py + 24, 22, 5);
        ctx.fillStyle = "#ffd700";
        ctx.fillRect(px + 14, py + 23, 8, 7);
        
        // Santa's head
        ctx.fillStyle = "#ffcc80";
        ctx.beginPath();
        ctx.arc(px + 18, py + 2, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // White beard
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(px + 18, py + 10, 10, 0, Math.PI);
        ctx.fill();
        ctx.fillRect(px + 8, py + 4, 20, 8);
        
        // Santa hat - tip trails behind when moving with wave animation
        // Since we're inside a flip transform, always use negative offset when moving (trails behind visually)
        // The flip transform will make it appear correct for both directions
        const isMoving = Math.abs(P.vx) > 0.5;
        const speed = Math.abs(P.vx);
        const waveTime = Date.now() / 100;
        // Wave amplitude increases with speed
        const waveAmplitude = isMoving ? Math.min(speed * 0.8, 4) : 0;
        const waveOffset = Math.sin(waveTime) * waveAmplitude;
        const hatTipOffset = isMoving ? -12 - waveAmplitude : 0; // Trail behind with wave
        const hatTipY = isMoving ? -18 + waveOffset : -20; // Vertical wave motion
        
        ctx.fillStyle = "#c62828";
        ctx.beginPath();
        ctx.moveTo(px + 8, py - 2);
        ctx.lineTo(px + 28, py - 2);
        // Add a curve to the hat when moving for a flowing effect
        if (isMoving) {
          ctx.quadraticCurveTo(
            px + 20 + hatTipOffset * 0.5, py - 10 + waveOffset * 0.5,
            px + 18 + hatTipOffset, py + hatTipY
          );
        } else {
          ctx.lineTo(px + 18 + hatTipOffset, py + hatTipY);
        }
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.fillRect(px + 6, py - 4, 24, 5);
        ctx.beginPath();
        ctx.arc(px + 18 + hatTipOffset, py + hatTipY, 5, 0, Math.PI * 2); // Pom-pom follows tip
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = "#333";
        const eyeDir = P.right ? 2 : -2;
        ctx.beginPath();
        ctx.arc(px + 14 + eyeDir, py, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(px + 22 + eyeDir, py, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Rosy cheeks
        ctx.fillStyle = "rgba(255,100,100,0.5)";
        ctx.beginPath();
        ctx.arc(px + 10, py + 4, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(px + 26, py + 4, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.arc(px + 18, py + 3, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Santa's arm (waving or holding reins)
        ctx.fillStyle = "#c62828";
        const armWave = Math.sin(Date.now() / 200) * 5;
        ctx.save();
        ctx.translate(px + 5, py + 14);
        ctx.rotate(-0.3 + armWave * 0.02);
        ctx.fillRect(0, 0, 6, 16);
        // White cuff
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 12, 6, 4);
        // Glove
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(3, 18, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Restore from the direction flip
        ctx.restore();
        
        // Turbo effect (flames behind sleigh - always at the back based on direction)
        if (turboActive) {
          const flameOffset = Math.sin(Date.now() / 50) * 3;
          const flameX = P.right ? px - 10 : px + P.w + 10;
          const flameDir = P.right ? -1 : 1;
          
          ctx.fillStyle = "#ff6600";
          ctx.beginPath();
          ctx.moveTo(flameX, py + P.h - 10);
          ctx.lineTo(flameX + flameDir * (20 + flameOffset), py + P.h - 5);
          ctx.lineTo(flameX, py + P.h);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#ffff00";
          ctx.beginPath();
          ctx.moveTo(flameX + flameDir * 2, py + P.h - 8);
          ctx.lineTo(flameX + flameDir * (12 + flameOffset * 0.5), py + P.h - 5);
          ctx.lineTo(flameX + flameDir * 2, py + P.h - 2);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();

        // Draw score popups
        for (const sp of scorePopups) {
          ctx.save();
          const alpha = sp.life / 60;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = sp.color;
          ctx.font = "bold 18px sans-serif";
          ctx.textAlign = "center";
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.strokeText(sp.text, sp.x - camX, sp.y);
          ctx.fillText(sp.text, sp.x - camX, sp.y);
          ctx.restore();
        }

        // Minimap
        drawMinimap();
      }

      function drawMinimap() {
        const mw = mini.width,
          mh = mini.height;
        const sc = mw / WORLD_W;

        mctx.fillStyle = "rgba(10,20,40,0.9)";
        mctx.fillRect(0, 0, mw, mh);

        // Ground
        mctx.fillStyle = "#555";
        mctx.fillRect(0, mh - 6, mw, 6);

        // Warehouse
        mctx.fillStyle = "#ffd93d";
        mctx.fillRect(warehouse.x * sc, mh - 15, warehouse.w * sc, 9);

        // Houses
        for (const h of houses) {
          mctx.fillStyle = h.needs ? "#ff6b6b" : h.done ? "#4caf50" : "#888";
          mctx.fillRect(h.x * sc, mh - 14, h.w * sc, 8);
        }

        // Power-ups
        for (const pu of powerUps) {
          if (!pu.collected) {
            mctx.fillStyle = pu.type === "stamina" ? "#4fc3f7" : "#ffd93d";
            mctx.beginPath();
            mctx.arc(pu.x * sc, mh - 18, 2, 0, Math.PI * 2);
            mctx.fill();
          }
        }

        // Player
        mctx.fillStyle = "#4fc3f7";
        mctx.beginPath();
        mctx.arc(P.x * sc, mh - 18, 3, 0, Math.PI * 2);
        mctx.fill();

        // Thief
        if (thief && !thiefDefeated) {
          mctx.fillStyle = "#ff4444";
          mctx.beginPath();
          mctx.arc(thief.x * sc, mh - 18, 3, 0, Math.PI * 2);
          mctx.fill();
          // Pulsing effect
          if (thief.suspicious) {
            mctx.strokeStyle = "rgba(255,68,68,0.6)";
            mctx.lineWidth = 2;
            mctx.beginPath();
            mctx.arc(thief.x * sc, mh - 18, 5, 0, Math.PI * 2);
            mctx.stroke();
          }
        }

        // View area
        mctx.strokeStyle = "rgba(255,255,255,0.4)";
        mctx.lineWidth = 1;
        mctx.strokeRect(camX * sc, 2, W * sc, mh - 8);
      }

      function showCombo(count) {
        // Disabled - keeping minimal UI
        return;
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }
// Handle window resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    W = canvas.width;
    H = canvas.height;
    GROUND = H - 50;
    
    // Adjust player position if needed
    if (P.y > GROUND - P.h) {
        P.y = GROUND - P.h;
    }
});
      // Handle window resize
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        W = canvas.width;
        H = canvas.height;
        GROUND = H - 50;
        
        // Adjust player position if needed
        if (P.y > GROUND - P.h) {
          P.y = GROUND - P.h;
        }
        
        // Update warehouse position
        if (warehouse) {
          warehouse.y = GROUND - 90;
        }
        
        // Update houses positions
        for (const h of houses) {
          h.y = GROUND - 70;
        }
      });

      loop();
    </script>
  </body>
</html>
